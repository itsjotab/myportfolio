{"ast":null,"code":"import { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nconst kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true); // ul: true,\n// ol: true,\n\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true); // table: true,\n// tr: true,\n\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\n\nexport default class HTMLElement extends Node {\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  constructor(tagName, keyAttrs) {\n    let rawAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let parentNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super();\n    this.rawAttrs = rawAttrs;\n    this.parentNode = parentNode;\n    this.classNames = [];\n    /**\n     * Node Type declaration.\n     */\n\n    this.nodeType = NodeType.ELEMENT_NODE;\n    this.rawTagName = tagName;\n    this.rawAttrs = rawAttrs || '';\n    this.parentNode = parentNode || null;\n    this.childNodes = [];\n\n    if (keyAttrs.id) {\n      this.id = keyAttrs.id;\n\n      if (!rawAttrs) {\n        this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n      }\n    }\n\n    if (keyAttrs.class) {\n      this.classNames = keyAttrs.class.split(/\\s+/);\n\n      if (!rawAttrs) {\n        const cls = `class=\"${this.classNames.join(' ')}\"`;\n\n        if (this.rawAttrs) {\n          this.rawAttrs += ` ${cls}`;\n        } else {\n          this.rawAttrs = cls;\n        }\n      }\n    }\n  }\n  /**\n   * Remove current element\n   */\n\n\n  remove() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      this.parentNode.childNodes = children.filter(child => {\n        return this !== child;\n      });\n    }\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n\n\n  removeChild(node) {\n    this.childNodes = this.childNodes.filter(child => {\n      return child !== node;\n    });\n  }\n  /**\n   * Exchanges given child with new child\n   * @param {HTMLElement} oldNode     node to exchange\n   * @param {HTMLElement} newNode     new node\n   */\n\n\n  exchangeChild(oldNode, newNode) {\n    const children = this.childNodes;\n    this.childNodes = children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n\n      return child;\n    });\n  }\n\n  get tagName() {\n    return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n  }\n  /**\n   * Get escpaed (as-it) text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get rawText() {\n    return this.childNodes.reduce((pre, cur) => {\n      return pre += cur.rawText;\n    }, '');\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get text() {\n    return decode(this.rawText);\n  }\n  /**\n   * Get structured Text (with '\\n' etc.)\n   * @return {string} structured text\n   */\n\n\n  get structuredText() {\n    let currentBlock = [];\n    const blocks = [currentBlock];\n\n    function dfs(node) {\n      if (node.nodeType === NodeType.ELEMENT_NODE) {\n        if (kBlockElements.get(node.rawTagName)) {\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n\n          node.childNodes.forEach(dfs);\n\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n        } else {\n          node.childNodes.forEach(dfs);\n        }\n      } else if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          // Whitespace node, postponed output\n          currentBlock.prependWhitespace = true;\n        } else {\n          let text = node.text;\n\n          if (currentBlock.prependWhitespace) {\n            text = ` ${text}`;\n            currentBlock.prependWhitespace = false;\n          }\n\n          currentBlock.push(text);\n        }\n      }\n    }\n\n    dfs(this);\n    return blocks.map(block => {\n      // Normalize each line's whitespace\n      return block.join('').trim().replace(/\\s{2,}/g, ' ');\n    }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n  }\n\n  toString() {\n    const tag = this.rawTagName;\n\n    if (tag) {\n      const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n      const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n\n      if (is_void) {\n        return `<${tag}${attrs}>`;\n      }\n\n      return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n    }\n\n    return this.innerHTML;\n  }\n\n  get innerHTML() {\n    return this.childNodes.map(child => {\n      return child.toString();\n    }).join('');\n  }\n\n  set_content(content) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (content instanceof Node) {\n      content = [content];\n    } else if (typeof content == 'string') {\n      const r = parse(content, options);\n      content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n    }\n\n    this.childNodes = content;\n  }\n\n  get outerHTML() {\n    return this.toString();\n  }\n  /**\n   * Trim element from right (in block) after seeing pattern in a TextNode.\n   * @param  {RegExp} pattern pattern to find\n   * @return {HTMLElement}    reference to current node\n   */\n\n\n  trimRight(pattern) {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const childNode = this.childNodes[i];\n\n      if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n        childNode.trimRight(pattern);\n      } else {\n        const index = childNode.rawText.search(pattern);\n\n        if (index > -1) {\n          childNode.rawText = childNode.rawText.substr(0, index); // trim all following nodes.\n\n          this.childNodes.length = i + 1;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get DOM structure\n   * @return {string} strucutre\n   */\n\n\n  get structure() {\n    const res = [];\n    let indention = 0;\n\n    function write(str) {\n      res.push('  '.repeat(indention) + str);\n    }\n\n    function dfs(node) {\n      const idStr = node.id ? `#${node.id}` : '';\n      const classStr = node.classNames.length ? `.${node.classNames.join('.')}` : '';\n      write(node.rawTagName + idStr + classStr);\n      indention++;\n      node.childNodes.forEach(childNode => {\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          dfs(childNode);\n        } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n          if (!childNode.isWhitespace) {\n            write('#text');\n          }\n        }\n      });\n      indention--;\n    }\n\n    dfs(this);\n    return res.join('\\n');\n  }\n  /**\n   * Remove whitespaces in this sub tree.\n   * @return {HTMLElement} pointer to this\n   */\n\n\n  removeWhitespace() {\n    let o = 0;\n    this.childNodes.forEach(node => {\n      if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          return;\n        }\n\n        node.rawText = node.rawText.trim();\n      } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n        node.removeWhitespace();\n      }\n\n      this.childNodes[o++] = node;\n    });\n    this.childNodes.length = o;\n    return this;\n  }\n  /**\n   * Query CSS selector to find matching nodes.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement[]}  matching elements\n   */\n\n\n  querySelectorAll(selector) {\n    let matcher;\n\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      if (selector.includes(',')) {\n        const selectors = selector.split(',');\n        return Array.from(selectors.reduce((pre, cur) => {\n          const result = this.querySelectorAll(cur.trim());\n          return result.reduce((p, c) => {\n            return p.add(c);\n          }, pre);\n        }, new Set()));\n      }\n\n      matcher = new Matcher(selector);\n    }\n\n    const stack = [];\n    return this.childNodes.reduce((res, cur) => {\n      stack.push([cur, 0, false]);\n\n      while (stack.length) {\n        const state = arr_back(stack); // get last element\n\n        const el = state[0];\n\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n\n          const html_el = el;\n          state[2] = matcher.advance(html_el);\n\n          if (state[2]) {\n            if (matcher.matched) {\n              res.push(html_el);\n              res.push(...html_el.querySelectorAll(selector)); // no need to go further.\n\n              matcher.rewind();\n              stack.pop();\n              continue;\n            }\n          }\n        }\n\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) {\n            matcher.rewind();\n          }\n\n          stack.pop();\n        }\n      }\n\n      return res;\n    }, []);\n  }\n  /**\n   * Query CSS Selector to find matching node.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement}    matching node\n   */\n\n\n  querySelector(selector) {\n    let matcher;\n\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      matcher = new Matcher(selector);\n    }\n\n    const stack = [];\n\n    for (const node of this.childNodes) {\n      stack.push([node, 0, false]);\n\n      while (stack.length) {\n        const state = arr_back(stack);\n        const el = state[0];\n\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n\n          state[2] = matcher.advance(el);\n\n          if (state[2]) {\n            if (matcher.matched) {\n              return el;\n            }\n          }\n        }\n\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) {\n            matcher.rewind();\n          }\n\n          stack.pop();\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Append a child node to childNodes\n   * @param  {Node} node node to append\n   * @return {Node}      node appended\n   */\n\n\n  appendChild(node) {\n    // node.parentNode = this;\n    this.childNodes.push(node);\n\n    if (node instanceof HTMLElement) {\n      node.parentNode = this;\n    }\n\n    return node;\n  }\n  /**\n   * Get first child node\n   * @return {Node} first child node\n   */\n\n\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  /**\n   * Get last child node\n   * @return {Node} last child node\n   */\n\n\n  get lastChild() {\n    return arr_back(this.childNodes);\n  }\n  /**\n   * Get attributes\n   * @return {Object} parsed and unescaped attributes\n   */\n\n\n  get attributes() {\n    if (this._attrs) {\n      return this._attrs;\n    }\n\n    this._attrs = {};\n    const attrs = this.rawAttributes;\n\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      this._attrs[key] = decode(val);\n    }\n\n    return this._attrs;\n  }\n  /**\n   * Get escaped (as-it) attributes\n   * @return {Object} parsed attributes\n   */\n\n\n  get rawAttributes() {\n    if (this._rawAttrs) {\n      return this._rawAttrs;\n    }\n\n    const attrs = {};\n\n    if (this.rawAttrs) {\n      const re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n      let match;\n\n      while (match = re.exec(this.rawAttrs)) {\n        attrs[match[1]] = match[2] || match[3] || match[4] || null;\n      }\n    }\n\n    this._rawAttrs = attrs;\n    return attrs;\n  }\n\n  removeAttribute(key) {\n    const attrs = this.rawAttributes;\n    delete attrs[key]; // Update this.attribute\n\n    if (this._attrs) {\n      delete this._attrs[key];\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n\n      if (val === undefined || val === 'null') {\n        return name;\n      }\n\n      return `${name}=${val}`;\n    }).join(' ');\n  }\n\n  hasAttribute(key) {\n    return key in this.attributes;\n  }\n  /**\n   * Get an attribute\n   * @return {string} value of the attribute\n   */\n\n\n  getAttribute(key) {\n    return this.attributes[key];\n  }\n  /**\n   * Set an attribute value to the HTMLElement\n   * @param {string} key The attribute name\n   * @param {string} value The value to set, or null / undefined to remove an attribute\n   */\n\n\n  setAttribute(key, value) {\n    if (arguments.length < 2) {\n      throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n    }\n\n    const attrs = this.rawAttributes;\n    attrs[key] = String(value);\n\n    if (this._attrs) {\n      this._attrs[key] = decode(attrs[key]);\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n\n      return `${name}=${val}`;\n    }).join(' ');\n  }\n  /**\n   * Replace all the attributes of the HTMLElement by the provided attributes\n   * @param {Attributes} attributes the new attribute set\n   */\n\n\n  setAttributes(attributes) {\n    // Invalidate current this.attributes\n    if (this._attrs) {\n      delete this._attrs;\n    } // Invalidate current this.rawAttributes\n\n\n    if (this._rawAttrs) {\n      delete this._rawAttrs;\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attributes).map(name => {\n      const val = attributes[name];\n\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n\n      return `${name}=${JSON.stringify(String(val))}`;\n    }).join(' ');\n  }\n\n  insertAdjacentHTML(where, html) {\n    if (arguments.length < 2) {\n      throw new Error('2 arguments required');\n    }\n\n    const p = parse(html);\n\n    if (where === 'afterend') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else if (where === 'afterbegin') {\n      this.childNodes.unshift(...p.childNodes);\n    } else if (where === 'beforeend') {\n      p.childNodes.forEach(n => {\n        this.appendChild(n);\n      });\n    } else if (where === 'beforebegin') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else {\n      throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n    } // if (!where || html === undefined || html === null) {\n    // \treturn;\n    // }\n\n  }\n\n  get nextSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n\n      while (i < children.length) {\n        const child = children[i++];\n\n        if (this === child) {\n          return children[i] || null;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  get nextElementSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      let find = false;\n\n      while (i < children.length) {\n        const child = children[i++];\n\n        if (find) {\n          if (child instanceof HTMLElement) {\n            return child || null;\n          }\n        } else if (this === child) {\n          find = true;\n        }\n      }\n\n      return null;\n    }\n  }\n\n} // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig; // <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n  area: true,\n  AREA: true,\n  base: true,\n  BASE: true,\n  br: true,\n  BR: true,\n  col: true,\n  COL: true,\n  hr: true,\n  HR: true,\n  img: true,\n  IMG: true,\n  input: true,\n  INPUT: true,\n  link: true,\n  LINK: true,\n  meta: true,\n  META: true,\n  source: true,\n  SOURCE: true,\n  embed: true,\n  EMBED: true,\n  param: true,\n  PARAM: true,\n  track: true,\n  TRACK: true,\n  wbr: true,\n  WBR: true\n};\nconst kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nconst kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nconst frameflag = 'documentfragmentcontainer';\nexport function parse(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lowerCaseTagName: false,\n    comment: false\n  };\n  const elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  const element_names = Object.keys(elements);\n  const kBlockTextElements = element_names.map(it => {\n    return new RegExp(it, 'i');\n  });\n  const kIgnoreElements = element_names.filter(it => {\n    return elements[it];\n  }).map(it => {\n    return new RegExp(it, 'i');\n  });\n\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(it => {\n      return it.test(tag);\n    });\n  }\n\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(it => {\n      return it.test(tag);\n    });\n  }\n\n  const root = new HTMLElement(null, {});\n  let currentParent = root;\n  const stack = [root];\n  let lastTextPos = -1;\n  let match; // https://github.com/taoqf/node-html-parser/issues/38\n\n  data = `<${frameflag}>${data}</${frameflag}>`;\n\n  while (match = kMarkupPattern.exec(data)) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text));\n      }\n    }\n\n    lastTextPos = kMarkupPattern.lastIndex;\n\n    if (match[2] === frameflag) {\n      continue;\n    }\n\n    if (match[0][1] === '!') {\n      // this is a comment\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n        currentParent.appendChild(new CommentNode(text));\n      }\n\n      continue;\n    }\n\n    if (options.lowerCaseTagName) {\n      match[2] = match[2].toLowerCase();\n    }\n\n    if (!match[1]) {\n      // not </ tags\n      const attrs = {};\n\n      for (let attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n\n      const tagName = currentParent.rawTagName;\n\n      if (!match[4] && kElementsClosedByOpening[tagName]) {\n        if (kElementsClosedByOpening[tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      } // ignore container tag we add above\n      // https://github.com/taoqf/node-html-parser/issues/38\n\n\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n      stack.push(currentParent);\n\n      if (is_block_text_element(match[2])) {\n        // a little test to find next </script> or </style> ...\n        const closeMarkup = `</${match[2]}>`;\n\n        const index = (() => {\n          if (options.lowerCaseTagName) {\n            return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n          }\n\n          return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        })();\n\n        if (element_should_be_ignore(match[2])) {\n          let text;\n\n          if (index === -1) {\n            // there is no matching ending for the text element.\n            text = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            text = data.substring(kMarkupPattern.lastIndex, index);\n          }\n\n          if (text.length > 0) {\n            currentParent.appendChild(new TextNode(text));\n          }\n        }\n\n        if (index === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.rawTagName === match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          const tagName = currentParent.tagName; // Trying to close current tag, and move on\n\n          if (kElementsClosedByClosing[tagName]) {\n            if (kElementsClosedByClosing[tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          } // Use aggressive strategy to handle unmatching markups.\n\n\n          break;\n        }\n      }\n    }\n  }\n\n  const valid = Boolean(stack.length === 1);\n\n  if (!options.noFix) {\n    const response = root;\n    response.valid = valid;\n\n    while (stack.length > 1) {\n      // Handle each error elements.\n      const last = stack.pop();\n      const oneBefore = arr_back(stack);\n\n      if (last.parentNode && last.parentNode.parentNode) {\n        if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n          // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.parentNode.appendChild(child);\n          });\n          stack.pop();\n        } else {\n          // Single error  <div> <h3> </div> handle: Just removes <h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.appendChild(child);\n          });\n        }\n      } else {// If it's final element just skip.\n      }\n    }\n\n    response.childNodes.forEach(node => {\n      if (node instanceof HTMLElement) {\n        node.parentNode = null;\n      }\n    });\n    return response;\n  }\n\n  const response = new TextNode(data);\n  response.valid = valid;\n  return response;\n}","map":{"version":3,"names":["decode","Node","NodeType","TextNode","Matcher","arr_back","CommentNode","kBlockElements","Map","set","HTMLElement","constructor","tagName","keyAttrs","rawAttrs","parentNode","classNames","nodeType","ELEMENT_NODE","rawTagName","childNodes","id","class","split","cls","join","remove","children","filter","child","removeChild","node","exchangeChild","oldNode","newNode","map","toUpperCase","rawText","reduce","pre","cur","text","structuredText","currentBlock","blocks","dfs","get","length","push","forEach","TEXT_NODE","isWhitespace","prependWhitespace","block","trim","replace","toString","tag","is_void","test","attrs","innerHTML","set_content","content","options","r","parse","outerHTML","trimRight","pattern","i","childNode","index","search","substr","structure","res","indention","write","str","repeat","idStr","classStr","removeWhitespace","o","querySelectorAll","selector","matcher","reset","includes","selectors","Array","from","result","p","c","add","Set","stack","state","el","pop","html_el","advance","matched","rewind","querySelector","appendChild","firstChild","lastChild","attributes","_attrs","rawAttributes","key","val","_rawAttrs","re","match","exec","removeAttribute","Object","keys","name","JSON","stringify","undefined","hasAttribute","getAttribute","setAttribute","value","arguments","Error","String","setAttributes","insertAdjacentHTML","where","html","idx","findIndex","splice","n","unshift","nextSibling","nextElementSibling","find","kMarkupPattern","kAttributePattern","kSelfClosingElements","area","AREA","base","BASE","br","BR","col","COL","hr","HR","img","IMG","input","INPUT","link","LINK","meta","META","source","SOURCE","embed","EMBED","param","PARAM","track","TRACK","wbr","WBR","kElementsClosedByOpening","li","LI","div","P","DIV","b","B","td","th","TD","TH","h1","H1","h2","H2","h3","H3","h4","H4","h5","H5","h6","H6","kElementsClosedByClosing","ul","ol","UL","OL","a","A","I","tr","table","TR","TABLE","frameflag","data","lowerCaseTagName","comment","elements","blockTextElements","script","noscript","style","element_names","kBlockTextElements","it","RegExp","kIgnoreElements","element_should_be_ignore","some","is_block_text_element","root","currentParent","lastTextPos","lastIndex","substring","toLowerCase","attMatch","closeMarkup","toLocaleLowerCase","indexOf","valid","Boolean","noFix","response","last","oneBefore"],"sources":["/Users/itsjotab/portfolio/node_modules/node-html-parser/dist/esm/nodes/html.js"],"sourcesContent":["import { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nconst kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true);\n// ul: true,\n// ol: true,\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true);\n// table: true,\n// tr: true,\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null) {\n        super();\n        this.rawAttrs = rawAttrs;\n        this.parentNode = parentNode;\n        this.classNames = [];\n        /**\n         * Node Type declaration.\n         */\n        this.nodeType = NodeType.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || '';\n        this.parentNode = parentNode || null;\n        this.childNodes = [];\n        if (keyAttrs.id) {\n            this.id = keyAttrs.id;\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            this.classNames = keyAttrs.class.split(/\\s+/);\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classNames.join(' ')}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                }\n                else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Remove current element\n     */\n    remove() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            this.parentNode.childNodes = children.filter((child) => {\n                return this !== child;\n            });\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n    removeChild(node) {\n        this.childNodes = this.childNodes.filter((child) => {\n            return (child !== node);\n        });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n    exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child) => {\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n    get rawText() {\n        return this.childNodes.reduce((pre, cur) => {\n            return (pre += cur.rawText);\n        }, '');\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n    get structuredText() {\n        let currentBlock = [];\n        const blocks = [currentBlock];\n        function dfs(node) {\n            if (node.nodeType === NodeType.ELEMENT_NODE) {\n                if (kBlockElements.get(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                }\n                else {\n                    node.childNodes.forEach(dfs);\n                }\n            }\n            else if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                }\n                else {\n                    let text = node.text;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks.map((block) => {\n            // Normalize each line's whitespace\n            return block.join('').trim().replace(/\\s{2,}/g, ' ');\n        })\n            .join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n            if (is_void) {\n                return `<${tag}${attrs}>`;\n            }\n            return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes.map((child) => {\n            return child.toString();\n        }).join('');\n    }\n    set_content(content, options = {}) {\n        if (content instanceof Node) {\n            content = [content];\n        }\n        else if (typeof content == 'string') {\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n        }\n        this.childNodes = content;\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    trimRight(pattern) {\n        for (let i = 0; i < this.childNodes.length; i++) {\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            }\n            else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n    get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push('  '.repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node.id ? (`#${node.id}`) : '';\n            const classStr = node.classNames.length ? (`.${node.classNames.join('.')}`) : '';\n            write(node.rawTagName + idStr + classStr);\n            indention++;\n            node.childNodes.forEach((childNode) => {\n                if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                    dfs(childNode);\n                }\n                else if (childNode.nodeType === NodeType.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write('#text');\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node) => {\n            if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.rawText.trim();\n            }\n            else if (node.nodeType === NodeType.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement[]}  matching elements\n     */\n    querySelectorAll(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            if (selector.includes(',')) {\n                const selectors = selector.split(',');\n                return Array.from(selectors.reduce((pre, cur) => {\n                    const result = this.querySelectorAll(cur.trim());\n                    return result.reduce((p, c) => {\n                        return p.add(c);\n                    }, pre);\n                }, new Set()));\n            }\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        return this.childNodes.reduce((res, cur) => {\n            stack.push([cur, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack); // get last element\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    const html_el = el;\n                    state[2] = matcher.advance(html_el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            res.push(html_el);\n                            res.push(...(html_el.querySelectorAll(selector)));\n                            // no need to go further.\n                            matcher.rewind();\n                            stack.pop();\n                            continue;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n            return res;\n        }, []);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement}    matching node\n     */\n    querySelector(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        for (const node of this.childNodes) {\n            stack.push([node, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack);\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    state[2] = matcher.advance(el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            return el;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n    appendChild(node) {\n        // node.parentNode = this;\n        this.childNodes.push(node);\n        if (node instanceof HTMLElement) {\n            node.parentNode = this;\n        }\n        return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n    get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n    get lastChild() {\n        return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @return {Object} parsed and unescaped attributes\n     */\n    get attributes() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            this._attrs[key] = decode(val);\n        }\n        return this._attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n    get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n            let match;\n            while ((match = re.exec(this.rawAttrs))) {\n                attrs[match[1]] = match[2] || match[3] || match[4] || null;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === undefined || val === 'null') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    hasAttribute(key) {\n        return key in this.attributes;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n    getAttribute(key) {\n        return this.attributes[key];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n    setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n        }\n        const attrs = this.rawAttributes;\n        attrs[key] = String(value);\n        if (this._attrs) {\n            this._attrs[key] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n    setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes).map((name) => {\n            const val = attributes[name];\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${JSON.stringify(String(val))}`;\n        }).join(' ');\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error('2 arguments required');\n        }\n        const p = parse(html);\n        if (where === 'afterend') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else if (where === 'afterbegin') {\n            this.childNodes.unshift(...p.childNodes);\n        }\n        else if (where === 'beforeend') {\n            p.childNodes.forEach((n) => {\n                this.appendChild(n);\n            });\n        }\n        else if (where === 'beforebegin') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        // if (!where || html === undefined || html === null) {\n        // \treturn;\n        // }\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while (i < children.length) {\n                const child = children[i++];\n                if (this === child) {\n                    return children[i] || null;\n                }\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while (i < children.length) {\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n    area: true,\n    AREA: true,\n    base: true,\n    BASE: true,\n    br: true,\n    BR: true,\n    col: true,\n    COL: true,\n    hr: true,\n    HR: true,\n    img: true,\n    IMG: true,\n    input: true,\n    INPUT: true,\n    link: true,\n    LINK: true,\n    meta: true,\n    META: true,\n    source: true,\n    SOURCE: true,\n    embed: true,\n    EMBED: true,\n    param: true,\n    PARAM: true,\n    track: true,\n    TRACK: true,\n    wbr: true,\n    WBR: true\n};\nconst kElementsClosedByOpening = {\n    li: { li: true, LI: true },\n    LI: { li: true, LI: true },\n    p: { p: true, div: true, P: true, DIV: true },\n    P: { p: true, div: true, P: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    td: { td: true, th: true, TD: true, TH: true },\n    TD: { td: true, th: true, TD: true, TH: true },\n    th: { td: true, th: true, TD: true, TH: true },\n    TH: { td: true, th: true, TD: true, TH: true },\n    h1: { h1: true, H1: true },\n    H1: { h1: true, H1: true },\n    h2: { h2: true, H2: true },\n    H2: { h2: true, H2: true },\n    h3: { h3: true, H3: true },\n    H3: { h3: true, H3: true },\n    h4: { h4: true, H4: true },\n    H4: { h4: true, H4: true },\n    h5: { h5: true, H5: true },\n    H5: { h5: true, H5: true },\n    h6: { h6: true, H6: true },\n    H6: { h6: true, H6: true }\n};\nconst kElementsClosedByClosing = {\n    li: { ul: true, ol: true, UL: true, OL: true },\n    LI: { ul: true, ol: true, UL: true, OL: true },\n    a: { div: true, DIV: true },\n    A: { div: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    i: { div: true, DIV: true },\n    I: { div: true, DIV: true },\n    p: { div: true, DIV: true },\n    P: { div: true, DIV: true },\n    td: { tr: true, table: true, TR: true, TABLE: true },\n    TD: { tr: true, table: true, TR: true, TABLE: true },\n    th: { tr: true, table: true, TR: true, TABLE: true },\n    TH: { tr: true, table: true, TR: true, TABLE: true }\n};\nconst frameflag = 'documentfragmentcontainer';\nexport function parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it) => {\n        return new RegExp(it, 'i');\n    });\n    const kIgnoreElements = element_names.filter((it) => {\n        return elements[it];\n    }).map((it) => {\n        return new RegExp(it, 'i');\n    });\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    const root = new HTMLElement(null, {});\n    let currentParent = root;\n    const stack = [root];\n    let lastTextPos = -1;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    while ((match = kMarkupPattern.exec(data))) {\n        if (lastTextPos > -1) {\n            if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n                // if has content\n                const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n                currentParent.appendChild(new TextNode(text));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        if (match[2] === frameflag) {\n            continue;\n        }\n        if (match[0][1] === '!') {\n            // this is a comment\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n                currentParent.appendChild(new CommentNode(text));\n            }\n            continue;\n        }\n        if (options.lowerCaseTagName) {\n            match[2] = match[2].toLowerCase();\n        }\n        if (!match[1]) {\n            // not </ tags\n            const attrs = {};\n            for (let attMatch; (attMatch = kAttributePattern.exec(match[3]));) {\n                attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n            }\n            const tagName = currentParent.rawTagName;\n            if (!match[4] && kElementsClosedByOpening[tagName]) {\n                if (kElementsClosedByOpening[tagName][match[2]]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                }\n            }\n            // ignore container tag we add above\n            // https://github.com/taoqf/node-html-parser/issues/38\n            currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n            stack.push(currentParent);\n            if (is_block_text_element(match[2])) {\n                // a little test to find next </script> or </style> ...\n                const closeMarkup = `</${match[2]}>`;\n                const index = (() => {\n                    if (options.lowerCaseTagName) {\n                        return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                    }\n                    return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                })();\n                if (element_should_be_ignore(match[2])) {\n                    let text;\n                    if (index === -1) {\n                        // there is no matching ending for the text element.\n                        text = data.substr(kMarkupPattern.lastIndex);\n                    }\n                    else {\n                        text = data.substring(kMarkupPattern.lastIndex, index);\n                    }\n                    if (text.length > 0) {\n                        currentParent.appendChild(new TextNode(text));\n                    }\n                }\n                if (index === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                }\n                else {\n                    lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n                    match[1] = 'true';\n                }\n            }\n        }\n        if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n            // </ or /> or <br> etc.\n            while (true) {\n                if (currentParent.rawTagName === match[2]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                    break;\n                }\n                else {\n                    const tagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[tagName]) {\n                        if (kElementsClosedByClosing[tagName][match[2]]) {\n                            stack.pop();\n                            currentParent = arr_back(stack);\n                            continue;\n                        }\n                    }\n                    // Use aggressive strategy to handle unmatching markups.\n                    break;\n                }\n            }\n        }\n    }\n    const valid = Boolean(stack.length === 1);\n    if (!options.noFix) {\n        const response = root;\n        response.valid = valid;\n        while (stack.length > 1) {\n            // Handle each error elements.\n            const last = stack.pop();\n            const oneBefore = arr_back(stack);\n            if (last.parentNode && last.parentNode.parentNode) {\n                if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                    // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.parentNode.appendChild(child);\n                    });\n                    stack.pop();\n                }\n                else {\n                    // Single error  <div> <h3> </div> handle: Just removes <h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.appendChild(child);\n                    });\n                }\n            }\n            else {\n                // If it's final element just skip.\n            }\n        }\n        response.childNodes.forEach((node) => {\n            if (node instanceof HTMLElement) {\n                node.parentNode = null;\n            }\n        });\n        return response;\n    }\n    const response = new TextNode(data);\n    response.valid = valid;\n    return response;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}